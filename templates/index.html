<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- スマホ対応 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto Data Table (Multi Timeframe)</title>
  <style>
    /* --- ベーススタイル省略・同様に前回のCSSを適用できる --- */
    body {
      margin: 0;
      padding: 0;
      background-color: #2d2d2d;
      color: #ffffff;
      font-family: Arial, sans-serif;
    }
    h1 {
      text-align: center;
      margin: 16px 0;
      font-size: 1.4em;
    }
    .update-info, .search-container, .condition-buttons, .table-container {
      margin-bottom: 16px;
    }
    /* 省略: これまでのCSS（フィルタボタン、テーブルなど）を継承 */
  </style>
</head>
<body>
  <h1>Crypto Data (Multi Timeframe)</h1>

  <!-- 更新情報 -->
  <div class="update-info" style="display:flex; justify-content:center; gap:10px; flex-wrap:wrap;">
    <span id="last-updated">Last Updated:</span>
    <span id="latest-timestamp">Timestamp:</span>
  </div>

  <!-- TF + Bars + データ更新ボタン -->
  <div class="controls" style="display:flex; justify-content:center; gap:10px; flex-wrap:wrap; margin-bottom:12px;">
    <div>
      <label for="tf-select">Timeframe:</label>
      <select id="tf-select">
        <option value="5m">5m</option>
        <option value="15m">15m</option>
        <option value="30m">30m</option>
        <option value="1h" selected>1h</option>
        <option value="2h">2h</option>
        <option value="4h">4h</option>
        <option value="6h">6h</option>
        <option value="12h">12h</option>
        <option value="1d">1d</option>
      </select>
    </div>

    <div>
      <label for="bars-select">Bars:</label>
      <select id="bars-select">
        <option value="2">2</option>
        <option value="4" selected>4</option>
        <option value="6">6</option>
        <option value="8">8</option>
        <option value="10">10</option>
        <option value="12">12</option>
      </select>
    </div>

    <button id="fetch-data" class="update-button">データ更新</button>
  </div>

  <!-- 検索＆Clear -->
  <div class="search-container" style="text-align:center;">
    <input type="text" id="symbol-search" placeholder="Search by symbol" style="padding:4px;">
    <button id="clear-filters">Clear</button>
  </div>

  <!-- フィルタボタン群 -->
  <div class="condition-buttons" style="display:flex; justify-content:center; gap:8px; flex-wrap:wrap;">
    <!-- 価格変化率 -->
    <button id="price-positive">価格変化 ≧ 0</button>
    <button id="price-negative">価格変化 ＜ 0</button>
    <!-- 出来高変化率 -->
    <button id="volume-positive">出来高 ≧ 0</button>
    <button id="volume-negative">出来高 ＜ 0</button>
    <!-- OI変化率 -->
    <button id="oi-positive">OI変化 ≧ 0</button>
    <button id="oi-negative">OI変化 ＜ 0</button>
    <!-- ファンディング -->
    <button id="fr-positive">FR ≧ 0.0001</button>
    <button id="fr-negative">FR ＜ 0.0001</button>
    <!-- スパイク系 -->
    <button id="volume-spike">VolumeSpike</button>
    <button id="small-price">SmallPrice</button>
  </div>

  <!-- テーブル表示領域 -->
  <div class="table-container" id="table-container" style="width:100%; overflow-x:auto; margin-bottom:20px;"></div>

  <script>
    // ***** カラム定義 *****
    const columns = [
      { key: 'symbol',  label: 'Symbol' },
      { key: 'close',   label: 'Close' },
      { key: 'volume',  label: 'Volume' },
      { key: 'funding_rate', label: 'Funding' },
      { key: 'openInterest', label: 'OpenInt' },
      { key: 'price_change_rate',  label: '価格変化' },
      { key: 'volume_change_rate', label: '出来高変化' },
      { key: 'oi_change_rate',     label: 'OI変化' },
      { key: 'volume_spike_flag',  label: 'VolSpike' },
      { key: 'small_price_move_flag', label: 'SmallPrice' }
    ];

    // *** 要素取得 ***
    const tfSelect     = document.getElementById('tf-select');
    const barsSelect   = document.getElementById('bars-select');
    const fetchDataBtn = document.getElementById('fetch-data');

    const symbolSearch = document.getElementById('symbol-search');
    const clearFiltersButton = document.getElementById('clear-filters');

    const lastUpdatedSpan = document.getElementById('last-updated');
    const latestTimestampSpan = document.getElementById('latest-timestamp');
    const tableContainer = document.getElementById('table-container');

    // フィルタボタン
    const conditionButtons = {
      pricePositive: document.getElementById('price-positive'),
      priceNegative: document.getElementById('price-negative'),
      volumePositive: document.getElementById('volume-positive'),
      volumeNegative: document.getElementById('volume-negative'),
      oiPositive: document.getElementById('oi-positive'),
      oiNegative: document.getElementById('oi-negative'),
      frPositive: document.getElementById('fr-positive'),
      frNegative: document.getElementById('fr-negative'),
      volumeSpike:  document.getElementById('volume-spike'),
      smallPrice:   document.getElementById('small-price'),
    };

    let originalData = [];
    let currentSort  = { column: null, order: 'asc' };
    let filters = {
      priceChangeRate: null,
      volumeChangeRate: null,
      oiChangeRate: null,
      fundingRate: null,
      symbolSearch: '',
      volumeSpike: null,
      smallPrice: null
    };

    // *** (1) ページ読み込み時に /api/fetch 実行 → CSV生成 → /api/data?tf=XX&bars=YY 取得 ***
    window.addEventListener('DOMContentLoaded', async () => {
      // デフォルト tf=1h, bars=4
      tfSelect.value   = "1h";
      barsSelect.value = "4";

      // まずfetch_data.pyを実行 (POST /api/fetch)
      //  -> ここで全timeframe x barsを生成するか、1つだけを生成するかは運用方針次第
      await doFetchDataPy();

      // その後 /api/data?tf=1h&bars=4 を取得
      await fetchData();
    });

    // *** (2) fetch_data.py 実行 ***
    async function doFetchDataPy() {
      try {
        // ボタンUIがないので裏での呼び出し
        const resp = await fetch('/api/fetch', { method: 'POST' });
        if (!resp.ok) throw new Error('Error calling /api/fetch');
        console.log("fetch_data.py executed successfully.");
      } catch (err) {
        console.error("Error executing fetch_data.py", err);
      }
    }

    // *** (3) /api/data?tf=...,bars=... 取得 ***
    async function fetchData() {
      try {
        const tf   = tfSelect.value;   // "5m","15m","30m","1h" ...
        const bars = barsSelect.value; // "2","4","6" ...
        // 例: "/api/data?tf=1h&bars=4"
        const url = `/api/data?tf=${tf}&bars=${bars}`;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`Error fetching data: tf=${tf}, bars=${bars}`);

        originalData = await resp.json();

        // 更新日時
        const now = new Date().toLocaleString();
        lastUpdatedSpan.textContent = `Last Updated: ${now}`;

        applyFilters();
      } catch (err) {
        console.error(err);
        alert('データ取得に失敗しました。');
      }
    }

    // *** (4) UIで「更新」ボタン押下 => fetch_data.py => /api/data?tf=XX&bars=YY ***
    fetchDataBtn.addEventListener('click', async () => {
      try {
        fetchDataBtn.disabled = true;
        // 表示上の何かプログレスバーがあるなら表示
        // ここでは省略

        // 1) fetch_data.py 実行
        const resp = await fetch('/api/fetch', { method: 'POST' });
        if (!resp.ok) throw new Error('Error calling /api/fetch');

        // 2) 最新データ取得
        await fetchData();
        alert('データが更新されました！');
      } catch (err) {
        console.error(err);
        alert('データ更新中にエラーが発生しました。');
      } finally {
        fetchDataBtn.disabled = false;
      }
    });

    // *** (5) フィルタ + ソート ***
    function applyFilters() {
      let filtered = [...originalData];

      // price_change_rate
      if (filters.priceChangeRate === 'positive') {
        filtered = filtered.filter(r => r.price_change_rate >= 0);
      } else if (filters.priceChangeRate === 'negative') {
        filtered = filtered.filter(r => r.price_change_rate < 0);
      }
      // volume_change_rate
      if (filters.volumeChangeRate === 'positive') {
        filtered = filtered.filter(r => r.volume_change_rate >= 0);
      } else if (filters.volumeChangeRate === 'negative') {
        filtered = filtered.filter(r => r.volume_change_rate < 0);
      }
      // oi_change_rate
      if (filters.oiChangeRate === 'positive') {
        filtered = filtered.filter(r => r.oi_change_rate >= 0);
      } else if (filters.oiChangeRate === 'negative') {
        filtered = filtered.filter(r => r.oi_change_rate < 0);
      }
      // funding_rate
      if (filters.fundingRate === 'positive') {
        filtered = filtered.filter(r => r.funding_rate >= 0.0001);
      } else if (filters.fundingRate === 'negative') {
        filtered = filtered.filter(r => r.funding_rate < 0.0001);
      }
      // volume_spike_flag
      if (filters.volumeSpike) {
        filtered = filtered.filter(r => r.volume_spike_flag === true);
      }
      // small_price_move_flag
      if (filters.smallPrice) {
        filtered = filtered.filter(r => r.small_price_move_flag === true);
      }
      // シンボル検索
      if (filters.symbolSearch) {
        filtered = filtered.filter(r =>
          r.symbol.toLowerCase().includes(filters.symbolSearch.toLowerCase())
        );
      }
      // ソート
      if (currentSort.column) {
        filtered.sort((a, b) => {
          const valA = a[currentSort.column];
          const valB = b[currentSort.column];
          if (currentSort.order === 'asc') {
            return valA > valB ? 1 : -1;
          } else {
            return valA < valB ? 1 : -1;
          }
        });
      }
      renderTable(filtered);
    }

    function renderTable(data) {
      let latestTS = '';
      if (data.length > 0) {
        latestTS = data.reduce((acc, row) => {
          if (row.timestamp && row.timestamp > acc) return row.timestamp;
          return acc;
        }, '');
      }
      latestTimestampSpan.textContent = `Timestamp: ${latestTS || 'N/A'}`;

      // テーブル
      let html = `
        <table class="data">
          <thead>
            <tr>
              ${columns.map(col => {
                const sortIcon =
                  currentSort.column === col.key
                    ? (currentSort.order === 'asc' ? '▲' : '▼')
                    : '';
                return `<th onclick="sortTable('${col.key}')">${col.label} ${sortIcon}</th>`;
              }).join('')}
            </tr>
          </thead>
          <tbody>
      `;
      data.forEach(row => {
        html += '<tr>';
        columns.forEach(col => {
          let val = row[col.key];
          if (col.key === 'symbol') {
            html += `<td class="symbol-cell">${val}</td>`;
          } else if (col.key.includes('_change_rate')) {
            // ±色分け
            html += `<td class="${val >= 0 ? 'positive' : 'negative'}">${val}%</td>`;
          } else if (col.key === 'funding_rate') {
            const cls = (val >= 0.0001) ? 'positive' : 'negative';
            html += `<td class="${cls}">${val}</td>`;
          } else if (col.key === 'volume_spike_flag' || col.key === 'small_price_move_flag') {
            html += `<td>${val ? 'Yes' : 'No'}</td>`;
          } else {
            html += `<td>${val}</td>`;
          }
        });
        html += '</tr>';
      });
      html += '</tbody></table>';
      tableContainer.innerHTML = html;
    }

    window.sortTable = function(colKey) {
      if (currentSort.column === colKey) {
        currentSort.order = (currentSort.order === 'asc') ? 'desc' : 'asc';
      } else {
        currentSort.column = colKey;
        currentSort.order = 'asc';
      }
      applyFilters();
    };

    // *** (6) フィルタボタン イベント ***
    Object.keys(conditionButtons).forEach(key => {
      const btn = conditionButtons[key];
      btn.addEventListener('click', () => {
        switch(key) {
          case 'pricePositive':
            toggleFilter('priceChangeRate', 'positive', btn); break;
          case 'priceNegative':
            toggleFilter('priceChangeRate', 'negative', btn); break;
          case 'volumePositive':
            toggleFilter('volumeChangeRate', 'positive', btn); break;
          case 'volumeNegative':
            toggleFilter('volumeChangeRate', 'negative', btn); break;
          case 'oiPositive':
            toggleFilter('oiChangeRate', 'positive', btn); break;
          case 'oiNegative':
            toggleFilter('oiChangeRate', 'negative', btn); break;
          case 'frPositive':
            toggleFilter('fundingRate', 'positive', btn); break;
          case 'frNegative':
            toggleFilter('fundingRate', 'negative', btn); break;
          case 'volumeSpike':
            toggleFlag('volumeSpike', btn); break;
          case 'smallPrice':
            toggleFlag('smallPrice', btn); break;
        }
        applyFilters();
      });
    });

    function toggleFilter(filterKey, type, button) {
      filters[filterKey] = (filters[filterKey] === type) ? null : type;
      button.classList.toggle('active', filters[filterKey] === type);
    }
    function toggleFlag(filterKey, button) {
      filters[filterKey] = !filters[filterKey];
      button.classList.toggle('active', filters[filterKey]);
    }

    // (7) 検索
    symbolSearch.addEventListener('input', e => {
      filters.symbolSearch = e.target.value;
      applyFilters();
    });

    // (8) Clearボタン
    clearFiltersButton.addEventListener('click', () => {
      filters = {
        priceChangeRate: null,
        volumeChangeRate: null,
        oiChangeRate: null,
        fundingRate: null,
        symbolSearch: '',
        volumeSpike: null,
        smallPrice: null
      };
      Object.values(conditionButtons).forEach(btn => btn.classList.remove('active'));
      symbolSearch.value = '';
      applyFilters();
    });
  </script>
</body>
</html>
